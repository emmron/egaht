// Eghact Code Generator v2
// Compiles enhanced Eghact syntax to optimized JavaScript

@component CodeGenerator {
  @state {
    output: string = ""
    indentLevel: number = 0
    sourceMap: SourceMap = new SourceMap()
    optimizations: Set<string> = new Set()
    context: GeneratorContext = {
      inComponent: false,
      inAsync: false,
      reactiveVars: new Set(),
      computedProps: new Map()
    }
  }

  // Main generation entry point
  @generate(ast: AST, options: GeneratorOptions = {}) -> GeneratedCode {
    @state.optimizations = new Set(options.optimizations || [
      'inline',
      'deadCode',
      'constantFold',
      'treeshake'
    ])
    
    @writePrelude()
    @visitProgram(ast)
    @writePostlude()
    
    return {
      code: @state.output,
      sourceMap: @state.sourceMap.toString(),
      metadata: @extractMetadata(ast)
    }
  }

  // Write runtime imports
  @writePrelude() {
    @writeLine("// Generated by Eghact Compiler v2")
    @writeLine("import { reactive, computed, effect, h, Component } from '@eghact/runtime';")
    @writeLine("")
  }

  // Visit program node
  @visitProgram(node: ProgramNode) {
    for declaration in node.declarations {
      @visitDeclaration(declaration)
      @writeLine("")
    }
  }

  // Visit declarations with pattern matching
  @visitDeclaration(node: Declaration) {
    match node.type {
      case 'Component' => @visitComponent(node)
      case 'TypeAlias' => @visitTypeAlias(node)
      case 'Import' => @visitImport(node)
      case 'Export' => @visitExport(node)
      default => @visitStatement(node)
    }
  }

  // Generate component with optimizations
  @visitComponent(node: ComponentNode) {
    let className = node.name
    
    // Handle decorators
    for decorator in (node.decorators || []) {
      @writeDecorator(decorator)
    }
    
    @write(`class ${className} extends Component {`)
    @indent()
    
    // Constructor with props and state
    @writeLine("constructor(props) {")
    @indent()
    @writeLine("super(props);")
    
    // Initialize state
    if node.body.state {
      @writeLine("this.state = reactive({")
      @indent()
      @visitStateDeclaration(node.body.state)
      @outdent()
      @writeLine("});")
    }
    
    @outdent()
    @writeLine("}")
    
    // Generate computed properties
    for computed in node.body.computed {
      @visitComputedProperty(computed)
    }
    
    // Generate methods
    for method in node.body.methods {
      @visitMethod(method)
    }
    
    // Generate lifecycle hooks
    for lifecycle in node.body.lifecycle {
      @visitLifecycle(lifecycle)
    }
    
    // Generate render method
    if node.body.render {
      @visitRender(node.body.render)
    }
    
    @outdent()
    @write("}")
  }

  // Visit computed property with memoization
  @visitComputedProperty(node: ComputedNode) {
    @writeLine(`get ${node.name}() {`)
    @indent()
    
    if @shouldMemoize(node) {
      @writeLine(`if (!this._computed_${node.name}) {`)
      @indent()
      @writeLine(`this._computed_${node.name} = computed(() => {`)
      @indent()
      @visitExpression(node.body)
      @outdent()
      @writeLine("});")
      @outdent()
      @writeLine("}")
      @writeLine(`return this._computed_${node.name}.value;`)
    } else {
      @write("return ")
      @visitExpression(node.body)
      @writeLine(";")
    }
    
    @outdent()
    @writeLine("}")
  }

  // Visit pattern matching
  @visitMatch(node: MatchExpression) {
    if node.discriminant {
      @write("(() => {")
      @writeLine(`const _match = `)
      @visitExpression(node.discriminant)
      @writeLine(";")
      
      for (caseNode, index) in node.cases.entries() {
        if index === 0 {
          @write("if (")
        } else {
          @write("} else if (")
        }
        
        @visitPattern(caseNode.pattern, "_match")
        
        if caseNode.guard {
          @write(" && ")
          @visitExpression(caseNode.guard)
        }
        
        @writeLine(") {")
        @indent()
        @write("return ")
        @visitExpression(caseNode.consequent)
        @writeLine(";")
        @outdent()
      }
      
      @writeLine("}")
      @write("})()")
    } else {
      // Match without discriminant (like switch-true)
      @generateMatchWithoutDiscriminant(node)
    }
  }

  // Visit pattern for matching
  @visitPattern(pattern: Pattern, target: string) {
    match pattern.type {
      case 'LiteralPattern' => {
        @write(`${target} === ${pattern.value}`)
      }
      case 'IdentifierPattern' => {
        @write(`(${pattern.name} = ${target}, true)`)
      }
      case 'ArrayPattern' => {
        @write(`Array.isArray(${target})`)
        for (element, index) in pattern.elements.entries() {
          @write(" && ")
          @visitPattern(element, `${target}[${index}]`)
        }
      }
      case 'ObjectPattern' => {
        for (prop, index) in pattern.properties.entries() {
          if index > 0 @write(" && ")
          @write(`"${prop.key}" in ${target}`)
        }
      }
      case 'RangePattern' => {
        @write(`${target} >= ${pattern.start} && ${target} <= ${pattern.end}`)
      }
      case 'ConstructorPattern' => {
        @write(`${pattern.name}(`)
        for (arg, index) in pattern.args.entries() {
          if index > 0 @write(", ")
          @visitPattern(arg, `${target}._${index}`)
        }
        @write(")")
      }
    }
  }

  // Visit pipeline expression
  @visitPipeline(node: PipelineExpression) {
    // Transform a |> b |> c to c(b(a))
    let chain = []
    let current = node
    
    while current.type === 'PipelineExpression' {
      chain.unshift(current.operator)
      current = current.left
    }
    
    // Generate nested calls
    for (op, index) in chain.entries() {
      @visitExpression(op)
      @write("(")
    }
    
    @visitExpression(current)
    
    for _ in chain {
      @write(")")
    }
  }

  // Visit array comprehension
  @visitArrayComprehension(node: ArrayComprehension) {
    // Transform [for x in arr if cond => expr] to arr.filter().map()
    @write("(")
    @visitExpression(node.iterable)
    
    if node.condition {
      @write(".filter(")
      @visitPattern(node.element, "_item")
      @write(" => ")
      @visitExpression(node.condition)
      @write(")")
    }
    
    @write(".map(")
    @visitPattern(node.element, "_item")
    @write(" => ")
    @visitExpression(node.expression)
    @write("))")
  }

  // Visit JSX with optimizations
  @visitJSX(node: JSXElement) {
    if @shouldOptimizeJSX(node) {
      @generateOptimizedJSX(node)
    } else {
      @generateStandardJSX(node)
    }
  }

  // Generate optimized JSX
  @generateOptimizedJSX(node: JSXElement) {
    // For static JSX, generate pre-compiled vnodes
    let vnode = @precompileJSX(node)
    @write(`_static_vnode_${@getStaticId(node)}`)
  }

  // Generate standard JSX
  @generateStandardJSX(node: JSXElement) {
    @write("h(")
    
    // Tag name
    if node.opening.name.type === 'Identifier' {
      @write(`"${node.opening.name.name}"`)
    } else {
      @visitExpression(node.opening.name)
    }
    
    @write(", ")
    
    // Props
    @write("{")
    for (attr, index) in node.opening.attributes.entries() {
      if index > 0 @write(", ")
      @visitJSXAttribute(attr)
    }
    @write("}, ")
    
    // Children
    @write("[")
    for (child, index) in node.children.entries() {
      if index > 0 @write(", ")
      @visitJSXChild(child)
    }
    @write("])")
  }

  // Visit async generator
  @visitAsyncGenerator(node: AsyncGeneratorNode) {
    @write("async function* ")
    @write(node.name)
    @write("(")
    @visitParameters(node.params)
    @write(") ")
    @visitBlock(node.body)
  }

  // Optimization helpers
  @shouldInline(node: Node) -> boolean {
    return @state.optimizations.has('inline') && 
           node.inline === true &&
           @calculateInlineCost(node) < 10
  }

  @shouldMemoize(node: ComputedNode) -> boolean {
    return @calculateComputationCost(node) > 5
  }

  @shouldOptimizeJSX(node: JSXElement) -> boolean {
    return @state.optimizations.has('staticHoist') &&
           @isStaticJSX(node)
  }

  @isStaticJSX(node: JSXElement) -> boolean {
    // Check if JSX has no dynamic parts
    for attr in node.opening.attributes {
      if attr.value?.type === 'Expression' return false
    }
    
    for child in node.children {
      if child.type === 'JSXExpression' return false
      if child.type === 'JSXElement' && !@isStaticJSX(child) return false
    }
    
    return true
  }

  // Dead code elimination
  @eliminateDeadCode(ast: AST) -> AST {
    // Remove unreachable code
    return @transformAST(ast, (node) => {
      match node.type {
        case 'IfStatement' => {
          if @isConstant(node.test) {
            return @evaluateConstant(node.test) ? node.consequent : node.alternate
          }
        }
        case 'ConditionalExpression' => {
          if @isConstant(node.test) {
            return @evaluateConstant(node.test) ? node.consequent : node.alternate
          }
        }
      }
      return node
    })
  }

  // Constant folding
  @foldConstants(node: Expression) -> Expression {
    match node.type {
      case 'BinaryExpression' => {
        let left = @foldConstants(node.left)
        let right = @foldConstants(node.right)
        
        if @isConstant(left) && @isConstant(right) {
          return @evaluateBinary(node.operator, left, right)
        }
      }
      case 'UnaryExpression' => {
        let arg = @foldConstants(node.argument)
        if @isConstant(arg) {
          return @evaluateUnary(node.operator, arg)
        }
      }
    }
    return node
  }

  // Helper methods
  @indent() {
    @state.indentLevel++
  }

  @outdent() {
    @state.indentLevel--
  }

  @write(code: string) {
    @state.output += code
  }

  @writeLine(code: string = "") {
    @write(code)
    @write("\n")
    @write("  ".repeat(@state.indentLevel))
  }

  @writeDecorator(decorator: Decorator) {
    @writeLine(`@${decorator.name}`)
  }
}

// Type definitions
@type GeneratorOptions {
  optimizations?: Array<string>
  sourceMap?: boolean
  target?: 'es2022' | 'es2020' | 'es2015'
  module?: 'esm' | 'commonjs'
}

@type GeneratedCode {
  code: string
  sourceMap: string
  metadata: Metadata
}

@type GeneratorContext {
  inComponent: boolean
  inAsync: boolean
  reactiveVars: Set<string>
  computedProps: Map<string, ComputedInfo>
}

// Export code generator
@export default CodeGenerator